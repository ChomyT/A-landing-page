/*try {
console.log('hello)
} catch(e) {
console.log('caught')
}
try {
  throw new Error();
  console.log('Hello');
} catch(err) {
  console.log('Goodbye');
}

function add(a, b) {
  console.log(a + b)
}*/

/*var result;
  console.log(result);
  var str = "Hello";
str.match("jello");
try {
  Number(5).toPrecision(300)
  } catch(e) {
  console.log("There was an error")
  }*/

  /*var str = "Hello";
str.match("jello");
console.log(str);*/
//perform currency conversions using functional programming
var currencyOne = 100;
var currencyTwo = 0;
var exchangeRate = 1.2;

function convertCurrency(amount, rate){
  return amount * rate;
  }
  currencyTwo = convertCurrency(currencyOne, exchangeRate);
  console.log(currencyTwo);
  
  console.log('hello world');

  function consoleLog(val){
    console.log(val)
    return val
  }
   function doubleIt(num){
    return num * 2
   }
   console.log (doubleIt(200));

   function objectMaker(val){
    return {
      prop: val
    }
   }
   console.log(objectMaker(20));
   //Functional Programming
   function getTotal(a, b){
    return a + b
   }
   var num1 = 2;
   var num2 = 3;
   var total = getTotal(num1, num2)
   console.log(total);
   //When writing FP code, we keep data and functionality separate and pass data into functions only when we want something computed.
   function getDistance(mph, h){
    return mph * h
   }
   var mph = 60;
   var h = 2;
   var distance = getDistance(mph, h);
   In functional programming, functions return new values and then use those values somewhere else in the code.
   function getDistance(mph, h){
    return mph * h
   }
   var mph = 60;
   var h = 2;
   var distance = getDistance(mph, h);
   console.log(distance);
   
   //creating an object
   var virtualPet = {
    sleepy: true,
    nap: function() {
      this.sleepy = false
    }
   }
console.log(virtualPet.sleepy) // true
virtualPet.nap()
console.log(virtualPet.sleepy) // fals